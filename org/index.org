#+TITLE:    zotherstupidguy log 
#+AUTHOR:    Mohamed Fouad
#+EMAIL:     zotherstupidguy@gmail.com
#+DESCRIPTION: daily log of zotherstupidguy life 
#+KEYWORDS:  emacs, mathematics, computer science, machine learning 
#+LANGUAGE:  en
#+STYLE:body {font-family: "Source Sans Pro Black",sans-serif;}
#+OPTIONS: H:3 num:4
#+TAGS: zpd0(0)  zpd1(1) zpd2(2)  problem solution predicate implication question fig mindmap number_theory set_theory proof_theory computational_theory problem_solving category_theory single_variable_calculas multi_variable_calculas vedic_mathematics graph_theory discerete_mathematics concerete_mathematics continous_mathematics statistics real_analysis grit top_universities studying_strategy data_structures algorithms artificial_intellegence machine_learning deep_learning bigdata R python puzzles { MOOC : coursera  stanford oxford MIT} { philosphy : socrates plato} book youtube blog competitive_programming C_programming {algorithms : ConstructiveAlgorithms Strings Sorting Search GraphTheory  Greedy DynamicProgramming  BitManipulation  Recursion GameTheory  NPComplete } DistributedSystems Regex Security Functions Cryptography
#+STARTUP: latexpreview

* Knowledge 
  (P) Any knowledge by definition is true & concise otherwise it would
  be some kind of misinformation.
  ...
** What is a String? :c_lang:
   A string is a contiguous sequence of code units terminated by the
   first zero code (\0, corresponding to the null character).

** What is the history of C? :c_lang:
   - C is a by-prodcut of the UNIX operating system.
   - When Ken Thompson wrote the original verision of UNIX on an 8k words
     of main memory minicomputer in assembly langauge, he decided that a
     higher level language is required for the further development of
     UNIX, thus he designed B, based on BCPL.
   - Ritchie joined the UNIX project and used B at first then when he
     needed an extended version of B, he created *C*!
  - The development of a U.S. standard for C began in 1983 under the
    uspices of the *American National Standards Institude (ANSI)*, later
    formally approvedin Dec 1989.
** What is the current stanadrd for C? :c_lang:
   C11 (C standard revision)
** What is POSIX?
   The Portable Operating System Interface (POSIX) is a family of
   standards specified by the IEEE Computer Society for maintaining
   compatibility between operating systems. POSIX defines the
   application programming interface (API), along with command line
   shells and utility interfaces, for software compatibility with
   variants of Unix and other operating systems.

** What are the nessesary language features for a C program?        :c_lang:
   Even The simplest C programs rely on three key language features:
   - directives: editing commands that modify the program prior to
     complications. i.e. *#include*, #include <stdio.h>, where stdio.h
     is a *header*. This directive states that the information in
     <stdio.h> is to be "included" into the program before it is complied.
   - functions: named blocks of executable code, of which main is an
     example. A C program is a collection of functions. functions fall
     into two categories: those written by the programmer and those
     provided as part of the C implementation (*library functions*).
     The term "function" comes from mathematics, where a function is
     a rule for computing a value when given one or more arguments.

     Only the main function is mandatory and it gets called
     automatically when the program is executed.
   - statments: commands to be performed when the program is run.


** What is a variable in a C program? :c_lang:
   - A variable is a labelled place to store some data.
   A variable is a temporarily storage location for data during C program
   execution.
   - Every variable must have a *type*, that specifies what kind of data
   it will hold.
   - C has a wide variety of types, how many in C99??? 


** What is a C pointer? :c_lang:
   A pointer is a *variable* containing the *address of another variable*.


** How a C pointer operates? :c_lang:

** What are C's "address of &"  and "dereferencing *" operators?     :c_lang:
   "&" (address of) and "*" dereferencing operators.*
   - *' & '* translates to *'give me the address of'*
   - *' * '* translates to *'give me whatever is that the address'*.
   - Example:  

     The dereference operator or indirection operator, denoted by "*" 
     (i.e. an asterisk), is a unary operator found in C-like languages 
     that include pointer variables.

     It operates on a pointer variable, and returns an l-value equivalent
     to the value at the pointer address. This is called "dereferencing"
     the pointer. 

     #+BEGIN_SRC C
       int x;

       // * is used in the declaration:
       // p is a pointer to an integer, 
       // since (after dereferencing),
       // *p is an integer
       int *p;  

       x = 0;
       // now x == 0
       p = &x;  // & takes the address of x
       // now p == &x, so *p == x
       ,*p = 1;  // equivalent to x = 1, since *p == x
       // now *p == 1 and *p == x, so x == 1
     #+END_SRC


** What is C's l-value? :c_lang:
   
** Why C has Pointers? :c_lang:

** What is C's *Segmentation Violations/Faults*? :c_lang:
   "segmentation violation" or "segmentation fault" means your program
   has attempted to access an area of memory that it is not allowed to
   access. In other words, it attempted to stomp on memory ground that
   is beyond the limits that the operating system (e.g., Unix) has
   allocated for your program.

** What are the causes of C's *Segmentation Violations/Faults*?      :c_lang:
- Improper format control string in printf or scanf statements
- Forgetting to use "&" on the arguments to scanf
- Accessing beyond the bounds of an array
- Failure to initialize a ointer before accessing it
- *Incorrect use of the "&" (address of) and "*" dereferencing operators.*
 
ref: http://web.mit.edu/10.001/Web/Tips/tips_on_segmentation.html

** What is Endianness?
   Endianness refers to the sequential order used to numerically
   interpret a range of bytes in computer memory as a larger, 
   composed word value.

** What is a *baud rate*? 
   The baud rate is the rate at which information is transferred in a
   communication channel. In the serial port context, "9600 baud" means 
   that the serial port is capable of transferring a maximum of 9600 
   bits per second.

** What is *Proof by Induction* ?

   - The idea is that if you want to show that someone can climb to the
   nth floor of a fire escape, you need only show that you can climb 
   the ladder up to the fire escape (n=1) and then show that you know 
   how to climb the stairs from any level of the fire escape (n=k) to 
   the next level (n=k+1).
   
   http://comet.lehman.cuny.edu/sormani/teaching/induction.html

** What is an *Approximation algorithm*?

** What is the *minimax algorithm*?

** What are the ... in 1 + r + r^2 + ... + r^n called?
   - "..." is an ellipsis.
   - it is used when the writer trying to tell the reader that there is an
     obvious pattern.

** What is an uncomputable function?
   https://web.stanford.edu/class/cs54n/handouts/15-UncomputableFunctions.pdf

** applying game theory in genetic algorithms?                         :idea:
   http://www.iitk.ac.in/nicee/wcee/article/11_1503.PDF
** what is *perfect randomness* ?
** What if the world doesn't have any *perfect randomness*(not pesuedorandomness)? :idea:
   I would define *randomness* as the inability of the beholder to
   identify patterns. In contradiction that the world is determinstic.
  
   thus, for the world to lack randomness, means that the beholder is
   capable of identifying patterns in everything! Is there a universal
   patten finding alogirhtm?
  
   Gemotric Algorithms (origami algorithms) shows that we can use
   diminsions to levelup our understanding of a subject. The more
   diminsions you can identify about a subject the more depth you
   develop with its understanding.

   Can we use the ability to construct diminsions regarding a subject
   to gain the ability to find a pattern matching algorithm in that
   that subject that would elimanite randomness and therefore makes
   finding the solution easy (P=NP)!  
 
   godel incompletness may 

** What is the difference between Big-O notation O(n) and Little-O notation o(n)? :time_complexity:



** What is a Walk? :graphtheory:
   a walk is a sequence of vertices connected by edges.


** What is a *bipartite graph*?
   In the mathematical field of graph theory, a bipartite graph (or
   bigraph) is a graph 
   whose vertices can be divided into two disjoint 
   sets {\displaystyle U} U and {\displaystyle V} V (that is,
   {\displaystyle U} U and {\displaystyle V} V 
   are each independent sets) such that every edge connects a vertex 
   in {\displaystyle U} U to one in {\displaystyle V} V. 
   Vertex sets {\displaystyle U} U and {\displaystyle V} V are usually 
   called the parts of the graph. Equivalently, a bipartite graph is a 
   graph that does not contain any odd-length cycles.
** What is *British Museum search algorithm*? :search_algorithm:
   backtracking: false
   use enqued list: false
   informed: false

** What is *Hill Climbing search algorithm*?
   backtracking: true 
   use enqued list: true 
   informed: true 

** What is *beam search algorithm*?
   backtracking: 
   use enqued list: 
   informed: 
   In computer science, beam search is a heuristic search algorithm that explores a graph 
   by expanding the most promising node in a limited set. 
   Beam search is an optimization of best-first search that reduces its memory requirements. 
   Best-first search is a graph search which orders all partial solutions (states) according 
   to some heuristic which attempts to predict how close a partial solution is to a complete 
   solution (goal state). But in beam search, only a predetermined number of best partial solutions are kept as candidates.

** What is Breadth First Search (BFS)?
   backtracking: false 
   use enqued list: true 
   informed: false 


** What is Depth First Search (DFS)?
   backtracking: true 
   use enqued list: true 
   informed: false 

 
   #+BEGIN_SRC C
     // void dfs(int a) // dfs on node a
     void hello() 
     {
       int x =  1 + 2; 
       printf("%i", x ); 
       // printf("hello world");
     }
     hello();
   #+END_SRC

   #+RESULTS:
   : 3

   - Refernces:
     - icpc.pdf page 10 of 78 
     - cp1.pdf page 70 of 152

** What is *backtracking*?

** Are all men created equal? 
   Yes, but then some learn science and become the *MASTERS* of others.

** Search is about Maps?
   No, *Search is about choice*, but for illustrations search uses maps.
   
** What is Educational Philsophy?  
   To solve problem we require transformation from one form into another(modeling skills).
   - modeling Skill \rightarrow require that we understand the skill, inorder to understand it, we need to witness on a level lower

   In 1960, he wrote it.

   Herustic Transformations

   apply all safe transforms -> look at the table -> done 


   What is an *AND NODE*?

** What does *herustic function*(herusticارشادي) mean?
   (Some kind of trick of substitions)
   In computer science, artificial intelligence, and mathematical optimization, 
   a heuristic is a technique designed for solving a problem more quickly when 
   classic methods are too slow, or for finding an approximate solution when 
   classic methods fail to find any exact solution. 
   
   This is achieved by trading optimality, completeness, accuracy, or precision for speed. 
   In a way, it can be considered a shortcut.

   A heuristic function, also called simply a heuristic, is a function that ranks alternatives 
   in search algorithms at each branching step based on available information to decide which 
   branch to follow. For example, it may approximate the exact solution.

** Why *knowledge about knowledge is Power!* ?
** What is the story of *Bertrand Russell being the Pope*
   The story goes that Bertrand Russell, in a lecture on logic, 
   mentioned that in the sense of material implication, *a false proposition implies any proposition.*

   A student raised his hand and said "In that case, given that 1 = 0, prove that you are the Pope."
   Russell immediately replied, "Add 1 to both sides of the equation: then we have 2 = 1. 
   The set containing just me and the Pope has 2 members. But 2 = 1, so it has only 1 member; therefore, I am the Pope." 
** What is Proof by Contradiction?
   If an assertion implies somthing false then the assertion itself must be false!

** What is a Proof?
** What is the Six Thinking Hats methdology?
** AI and Six Thinking Hats?
   six thinking hats says arguments are not good, 
   how about we use that to make computers solve problems more
   humanly! 

** What is Proof by Cases?
   Reasoning by cases breaks a complicated problem into easier subproblems.
   Some philosphers* think that reasoning by cases is worrisome.

** What is P = NP
   P stands for polynomial time, NP stands for non-determinstic Polynomial time

** What is Polynomial Time?
   The time required for a computer to solve a problem,  
   where this time is a simple polynomial function of the size of the input.

   In computational complexity theory, P, also known as PTIME or DTIME(nO(1)), 
   is a fundamental complexity class. It contains all decision
   problems that can be solved by a deterministic Turing machine using
   a polynomial amount of computation time, or polynomial time.

** What is a Polynomial Function?
   A polynomial function is a function such as a quadratic, a cubic, a quartic, and so on, involving
   only non-negative integer powers of x.

   In mathematics, a polynomial is an expression consisting of variables
   (or indeterminates) and coefficients, that involves only the
   operations of addition, subtraction, multiplication, and non-negative
   integer exponents. 

   An example of a polynomial of a single indeterminate x is x2 − 4x + 7. 
   An example in three variables is x3 + 2xyz2 − yz + 1.

** What is an Automaton?
   An automaton is a self-operating machine, or a machine or control mechanism designed to automatically 
   follow a predetermined sequence of operations, or respond to predetermined instructions.
   
** Whats the difference between Automaton and automata?
   *Automaton* is singular and *automata* is plural    

** What is Finite Automaton?
   - A Formal System
   - Remembers only a finite amount of infromation.
   - Information represented by its state.
   - State changes in response to its inputs.
   - Rules that tell how the state changes in response to inputs are called 
   transitions. 
** Whats the importance of Finite Automata?
   - Used for boh design and verification of circuits and communication protocols
   - Used for many text-processing applications.
   - An important component of compilers.
   - Describes simple patterns of events, etc.

** What is a language of an Automaton?
   - The set of strings accepted by an automaton A is the langauge of A.
   - Denoted L(A).
   - Different sets of final states implies different languages got inserted into the Automaton.
   - Example: As designed, L(Tennis) = strings that determine the winner.

** What is an alphabet?
   An alphabet is any finite set of symbols.
   - Examples: 
     - ASCII, Unicode,
     - {0,1} (binary alphabet) 
** What is a *string* over an alphabet \Sigma ?
   A string over an alphabet \Sigma is a list, each element of 
   which is a member of \[ \Sigma \] 
   ε(epsilon) is an empty string.
   \Sigma 	

** How can a computer program(finite automata) learn from experiance?
   A computer program is said to learn from experience E with respect
   to some class of tasks T and performance measure P, if its performance at tasks in
   T, as measured by P, improves with experience E.

   (i) A computer program that learns to play checkers might improve
   its performance as measured by its abiliry to win at the class of tasks involving
   playing checkers games, through experience obtained by playing games against
   itself.

   A checkers learning problem:
   - Task T: playing checkers
   - Performance measure P: percent of games won in the world tournament
   - Training experience E: games played against itself
     In order to complete the design of the learning system, we must now choose
     1. the exact type of knowledge to be,learned
     2. a representation for this target knowledge
     3. a learning mechanism

** How to analog Professor-students passing on of knowledge to Machine Learning? :idea:
   Prof. Automaton Probem :D 
 
   (idea) I was thinking that a Human(Professor) lives his life in stages, 
   stage1 his objective is to asks a lot of questions and gets a lot of answers, 
   stage2 his objective is to reflects on this knowledge and try to find new knowledge of his own.
   stage3 his objective is to teach all his knowledge to stage1 and stage2 humans 

   if we represent those stages(objectives of each stage) this into machine learning approaches,
   machines could be more capable of coperating towards an evolution.

** How to design a machine learning system?
   (idea) if we apply genetic algorithms on these design choices, programs create other programs?
*** Choosing the training experiance: 
    1. Does the training experience provides direct or indirect feedback regarding the choices
    made by the performance system?
    For example, in learning to play checkers, the system might learn from direct training 
    examples consisting of individual checkers board states and the correct move for each. 
    Alternatively, it might have available only indirect information consisting of the move 
    sequences and final outcomes of various games played. In this later case, information 
    about the correctness of specific moves early in the game must be inferred indirectly 
    from the fact that the game was eventually won or lost. Here the learner faces an additional
    problem of credit assignment, or determining the degree to which each move in
    the sequence deserves credit or blame for the final outcome. Credit assignment can
    be a particularly difficult problem because the game can be lost even when early
    moves are optimal, if these are followed later by poor moves. Hence, learning from
    direct training feedback is typically easier than learning from indirect feedback.

  
    2. To what degree does the learner controls the sequence of training examples?
    
    3. How well it represents the distribution of examples over which the final system 
    performance P must be measured?
    
    Most current theory of machine learning rests on the crucial assumption that the distribution of 
    training examples is identical to the distribution of test examples. 
    Despite our need to make this assumption in order to obtain theoretical results, 
    it is important to keep in mind that this assumption must often be violated in practice.

*** Choosing the Target function
    1. How to determine what type of knowledge will be learned?
    2. How this type of knowledge will be used by the performance program?

       The next design choice is to determine exactly what type of knowledge will be
       learned and how this will be used by the performance program.


    Let us begin with a checkers-playing program that can generate the legal moves from any board
    state. 

    The program needs only to learn how to choose the best move from among these legal moves. 

    This learning task is representative of a large class of tasks for which the legal moves that define 
    some large search space are known a priori, but for which the best search strategy is not known. 
    
    Many optimization problems fall into this class, such as the problems of scheduling 
    and controlling manufacturing processes where the available manufacturing steps are 
    well understood, but the best strategy for sequencing them is not.


    Given this setting where we must learn to choose among the legal moves,
    the most obvious choice for the type of information to be learned is a program,
    or function, that chooses the best move for any given board state. Let us call this
    function ChooseMove and use the notation ChooseMove : B -+ M to indicate
    that this function accepts as input any board from the set of legal board states B
    and produces as output some move from the set of legal moves M. Throughout
    our discussion of machine learning we will find it useful to reduce the problem
    of improving performance P at task T to the problem of learning some particu-
    lar targetfunction such as ChooseMove. The choice of the target function will
    therefore be a key design choice

    Although ChooseMove is an obvious choice for the target function in our
    example, this function will turn out to be very difficult to learn given the kind of in-
    direct training experience available to our system. An alternative target function-
    and one that will turn out to be easier to learn in this setting-is an evaluation
    function that assigns a numerical score to any given board state. Let us call this
    target function V and again use the notation V : B + 8 to denote that V maps
    any legal board state from the set B to some real value (we use 8 to denote the set
    of real numbers). We intend for this target function V to assign higher scores to
    better board states. If the system can successfully learn such a target function V ,
    then it can easily use it to select the best move from any current board position.
    This can be accomplished by generating the successor board state produced by
    every legal move, then using V to choose the best successor state and therefore
    the best legal move.
    What exactly should be the value of the target function V for any given
    board state? Of course any evaluation function that assigns higher scores to better
    board states will do. Nevertheless, we will find it useful to define one particular
    target function V among the many that produce optimal play. As we shall see,
    this will make it easier to design a training algorithm. Let us therefore define the
    target value V ( b ) for an arbitrary board state b in B , as follows:
    1. if b is a final board state that is won, then V ( b ) = 100
    2. if b is a final board state that is lost, then V ( b ) = -100
    3. if b is a final board state that is drawn, then V ( b ) = 04. if b is a not a final state in the game, then V(b) = V(bl), where b' is the best
    final board state that can be achieved starting from b and playing optimally
    until the end of the game (assuming the opponent plays optimally, as well).
    While this recursive definition specifies a value of V(b) for every board
    state b, this definition is not usable by our checkers player because it is not
    efficiently computable. Except for the trivial cases (cases 1-3) in which the game
    has already ended, determining the value of V(b) for a particular board state
    requires (case 4) searching ahead for the optimal line of play, all the way to
    the end of the game! Because this definition is not efficiently computable by our
    checkers playing program, we say that it is a nonoperational definition. The goal
    of learning in this case is to discover an operational description of V ; that is, a
    description that can be used by the checkers-playing program to evaluate states
    and select moves within realistic time bounds.
    Thus, we have reduced the learning task in this case to the problem of
    discovering an operational description of the ideal targetfunction V. It may be
    very difficult in general to learn such an operational form of V perfectly. In fact,
    we often expect learning algorithms to acquire only some approximation to the
    target function, and for this reason the process of learning the target function
    is often called function approximation. In the current discussion we will use the
    symbol ? to refer to the function that is actually learned by our program, to
    distinguish it from the ideal target function V.

*** Choosing a Representation for the Target Function
*** Choosing a Function Approximation Algorithm

** What are Karp's 21 NP-complete problems?
** What are Sudoku solving algorithms?
** How to visualize Eleven Dimensions?
** What is Donald Knuth's Dancing Links technique?
   In computer science, dancing links is the technique suggested by Donald Knuth to efficiently implement his Algorithm X.

** What is Donad Knuth's Algorithm X?
   Algorithm X is a recursive, nondeterministic, depth-first, backtracking algorithm that finds all solutions to the exact cover problem. 
   Some of the better-known exact cover problems include tiling, the n queens problem, and Sudoku.

** What AI is about?
   AI is about Algorithms enabled by constrains, exposed by representations, 
   that support the making of Models that facilitate an understanding of 
   thinking, preception, and actions.

** What are the Greek Letters?
   1. Α α (alpha)
   2. Β β (beta)
   3. Γ γ (gamma)
   4. Δ δ (delta)
   5. Ε ε (epsilon)
   6. Ϝ ϝ (digamma)
   7. Ζ ζ (zeta)
   8. Η η (eta)
   9. Θ θ (theta)
   10. Ι ι (iota)
   11. Κ κ (kappa)
   12. Λ λ (lambda)
   13. Μ μ (mu)
   14. Ν ν (nu)
   15. Ξ ξ (xi)
   16. Ο ο (omicron)
   17. Π π (pi)
   18. Ρ ρ (rho)
   19. Σ σ/ς (sigma)The letter sigma ⟨Σ⟩ has two different lowercase forms, ⟨σ⟩ and ⟨ς⟩, with ⟨ς⟩ being used in word-final position and ⟨σ⟩ elsewhere. 
   20. Τ τ (tau)
   21. Υ υ (upsilon)
   22. Φ φ (phi)
   23. Χ χ (chi)
   24. Ψ ψ (psi)
   25. Ω ω (omega)

** What is Declarative Kknowledge?
** What is Imperative Kknowledge?
** What are Turing's 6 primative instructions?
   (P) Alan Turing said there are only 6 primative instructions needed to create any program.

** What is Memoization?
   - Memoization is a very common techqiune, we use memoization to solve a lot of problems.
   - In simple terms, we are just remmbering what we did before and just look it up.
   - In summary,it is a fancy way to say we are going to use Table lookup.

** When to use Memoization?
   Thus in a situation where you remmber what the answer was and rather than recalculating it again, we just look it up.
   The concept of memoization is at the heart of dynamic programming.
   - References  
     (r) MIT - Introduction to Computer Science and Programming (Python) ® vampiri6ka/HQ     

** What is Dynamic Programming?
** What are Prime Numbers?                                :zpd:number_theory:
   (p) somthing is a predicate
   (i) somthing is impelied
   (q) a question
** What is Topological Sorting?
   Is a type of Depth First Search, 

  
   
   ---------

** What is Turing Complete?
   - In computability theory, a system of data-manipulation rules (such as a computer's instruction set, 
   a programming language, or a cellular automaton) is said to be Turing complete or computationally 
   universal if it can be used to simulate any single-taped Turing machine. 
   The concept is named after English mathematician Alan Turing. A classic example is lambda calculus.
   
** What is Turing Equivalence?
   
** What is Python?
   - interperted langauge, (can also complie it)
   - a variable is a name of an objective
   - an assigment binds a name to an object.
   - python forces indentation thus that the visual structure actually matchs the semantic structure. 

** What is Machine Learning? 
   - Machine Learning is a class of algorithms which is data-driven, 
   i.e. unlike "normal" algorithms it is the data that "tells" what the "good answer" is
   - Example: a hypothetical non-machine learning algorithm for face detection in images 
   would try to define what a face is (round skin-like-colored disk, with dark area where 
   you expect the eyes etc). A machine learning algorithm would not have such coded 
   definition, but would "learn-by-examples": you'll show several images of faces and 
   not-faces and a good algorithm will eventually learn and be able to predict whether or not an unseen image is a face. 
 
   - Machine Learning Types:
   Supervised: All data is labeled and the algorithms learn to predict the output from the input data.
   Unsupervised: All data is unlabeled and the algorithms learn to inherent structure from the input data.
   Semi-supervised: Some data is labeled but most of it is unlabeled and a mixture of supervised and unsupervised techniques can be used. 

** What is Supervised Learning?
   - Supervised learning is when the data you feed your algorithm is "tagged" to help your logic make decisions.
   - Example: Bayes spam filtering, where you have to flag an item as spam to refine the results.
   - Applications in which the training data comprises examples of the input vectors along with their 
   corresponding target vectors are known as supervised learning problems.
   - Approaches to supervised learning include:
     - Classification(1R, Naive Bayes, Decision tree learning algorithm such as ID3 CART and so on)
     - Numeric Value Prediction
   - Supervised learning: It is the machine learning task of inferring a function from labeled training data.The training data consist of a set of training examples. In supervised learning, each example is a pair consisting of an input object (typically a vector) and a desired output value (also called the supervisory signal). A supervised learning algorithm analyzes the training data and produces an inferred function, which can be used for mapping new examples.
   The computer is presented with example inputs and their desired outputs, given by a "teacher", and the goal is to learn a general rule that maps inputs to outputs.Specifically, a supervised learning algorithm takes a known set of input data and known responses to the data (output), and trains a model to generate reasonable predictions for the response to new data.
   - The classification and regression supervised learning problems.
** When to use supervised learning?

** What is Unsupervised Learning?
   - You should use unsupervised learning methods when you need a large amount of data to train your models, and the willingness and ability to experiment and explore, and of course a challenge that isn’t well solved via more-established methods.With unsupervised learning it is possible to learn larger and more complex models than with supervised learning.Here is a good example on it
   - Unsupervised learning are types of algorithms that try to find correlations without any external inputs other than the raw data.
   - Example: datamining clustering algorithms.
   - In other pattern recognition problems, the training data consists of a set of input vectors x without any corresponding target values.
     The goal in such unsupervised learning problems may be to discover groups of similar examples within the data, where it is called clustering
   - Approaches to unsupervised learning include:
     - Clustering(K-mean,hierarchical clustering)
     - Association Rule Learning
   - Unsupervised learning: It is learning without a teacher. 
   One basic thing that you might want to do with data is to visualize it. It is the machine learning task of inferring a function to describe hidden structure from unlabeled data. Since the examples given to the learner are unlabeled, there is no error or reward signal to evaluate a potential solution. This distinguishes unsupervised learning from supervised learning. Unsupervised learning uses procedures that attempt to find natural partitions of patterns.
   - The clustering and association unsupervised learning problems.
** When to use unsupervised learning?
** What is DeepCoder?
   * We develop a first line of attack for solving programming competition-style prob-
   lems from input-output examples using deep learning. The approach is to train a
   neural network to predict properties of the program that generated the outputs from
   the inputs. We use the neural network’s predictions to augment search techniques
   from the programming languages community, including enumerative search and
   an SMT-based solver. Empirically, we show that our approach leads to an order
   of magnitude speedup over the strong non-augmented baselines and a Recurrent
   Neural Network approach, and that we are able to solve problems of difficulty
   comparable to the simplest problems on programming competition websites.

** What is Semi-supervised Learning?
   - A problem that sits in between supervised and unsupervised learning called semi-supervised learning.
   - Problems where you have a large amount of input data (X) and only some of the data is labeled (Y) 
   are called semi-supervised learning problems.
   - Semi-supervised learning problems sit in between both supervised and unsupervised learning.
   - A good example is a photo archive where only some of the images are labeled, (e.g. dog, cat, person) and the majority are unlabeled.
   - Many real world machine learning problems fall into this area. This is because it can be expensive or 
     time-consuming to label data as it may require access to domain experts. Whereas unlabeled data is cheap and easy to collect and store.
   - You can use unsupervised learning techniques to discover and learn the structure in the input variables.
   - You can also use supervised learning techniques to make best guess predictions for the unlabeled data, 
     feed that data back into the supervised learning algorithm as training data and use the model to make predictions on new unseen data.
** What is active learning?
** What is PageRank?
** When to use Octave?
   (P) Always use octave for prototyping machine learning algorithms, and only after that migrate it in another language.
   (P) if we use octave as our programming enviroment for machine learning, will learn much more faster than
   using python, C++, or Java, as it is just functions.

** What is the Cocktail Party Problem?
   - in only one line of code! in octave.

** What is Linear Regression?
   - Regression means " انحسار"

   In statistics, linear regression is an approach for modeling the relationship between a scalar 
   dependent variable y and one or more explanatory variables (or independent variables) denoted X. 
 
   The case of one explanatory variable is called simple linear regression. 
   For more than one explanatory variable, the process is called multiple linear regression. 
   (This term is distinct from multivariate linear regression, where multiple correlated dependent 
   variables are predicted, rather than a single scalar variable.)

** What is Linear Regression with one variable (Univariate Linear Regression)?
*** Model Representation
    We have data that is plotted on a graph.
    This is supervised learning as we are given the "right answer" for each example in the data.
    This is a type of a Regression problem where we predict real-valued output. 

    m = Number of training examples
    x's = "input" variable/ features
    y's = "output" variable / "target" variable

    (          training set       )
    \Downarrow     
    (        learning algorithms  )
    \Downarrow     
    size of house \rightarrow  h   \rightarrow estimated price



*** Cost Function
    \ \odot = \theta + \Theta1 x 
**** Cost Function Intuition

*** Gardient Descent
**** Gardient Descent Intuition
**** Gardient Descent for Linear Regression
     
** What is Focused Crawling?
   A focused crawler is a web crawler that collects Web pages that satisfy some specific property, 
   by carefully prioritizing the crawl frontier and managing the hyperlink exploration process. 
   Some predicates may be based on simple, deterministic and surface properties. 
   For example, a crawler's mission may be to crawl pages from only the .jp domain. 
   Other predicates may be softer or comparative, e.g., "crawl pages with large PageRank", 
   or "crawl pages about baseball". An important page property pertains to topics, leading to 
   topical crawlers. For example, a topical crawler may be deployed to collect pages about solar power, 
   or swine flu, while minimizing resources spent fetching pages on other topics. Crawl frontier 
   management may not be the only device used by focused crawlers; they may use a Web directory, 
   a Web text index, backlinks, or any other Web artifact.

** What is Radix Sort?
   http://www.geeksforgeeks.org/radix-sort/ 

** What is an Order Statistic Tree?
** What is a B-tree?
** What is Binary Search Tree (BST)?
   

** What is *release the prisoners topology* ?

** References  
   +begin_src sh :results output :exports results
   ls /home/zotherstupidguy/Study/3.Sources/MIT6.042JMathematicsforComputerScienceSpring2015/*.mp4 | sort -n
   #ls /home/zotherstupidguy/Study/3.Sources/MITIntroductiontoComputerScienceandProgramming(Python)/HQ
   +end_src

   +RESULTS:
   +begin_example
   +end_example

*** TODO MITIntroductiontoComputerScienceandProgramming(Python) [%]
**** DONE 01-Lecture 01_ Introduction to 6.00
     CLOSED: [2017-02-24 Fri 17:37]
**** DONE 02-Lecture 
     CLOSED: [2017-02-24 Fri 17:37]
**** DONE 03-Lecture 
     CLOSED: [2017-02-25 Sat 05:45]
**** TODO 04-Lecture 
**** TODO 31-Lecture 21_ Using Graphs to Model Problems, Part 1

**** TODO 32-Lecture 22_ Using Graphs to Model Problems, Part 2

*** TODO TTC VIDEO - The Art and Craft of Mathematical Problem Solving [%] :problemsolving:
    :PROPERTIES:
    :ZPT:      0
    :DESCRIPTION: This is an online course blahblah
    :CATEGORY: problemsolving
    :CUSTOM_ID: an-extra-special-headline
    :END:
    * Diference between Problem and Exercise :: Scope doesn't work as expected, and messes everything up
         when loops mix variables up in recursive functions.
         - Namespaces :: You wish. 
         - Header Files :: Nope.
         information about the source here, author, edition, date, who is using it in univ cources, etc.

*** TODO Cracking the Coding Interview      [%]          :book:zpd:interview:
    :PROPERTIES:
    :BIB_AUTHOR: Walter Evensong
    :BIB_TITLE: Mysteries of the Amazon
    :BIB_PAGES: 1234
    :BIB_PUBLISHER: Humbug University Press
    :END:
****** TODO Chapter1 
******* TODO name of the heading in the chapter
******* TODO name of the heading in the chapter
****** DONE sfsf
****** sfsfsfsf

*** TODO arabic competitive programming   [%] :youtube:competitive_programming:
    - name of each eposide extracted via a script from Emacs and into a list here

*** TODO Introduction to the Theory of Computation - 3rd - Spiser [%]
    :PROPERTIES:
    :BIB_AUTHOR: Walter Evensong
    :BIB_TITLE: Mysteries of the Amazon
    :BIB_PAGES: 1234
    :BIB_PUBLISHER: Humbug University Press
    :END:
    - name of each chapter a list here

*** TODO hackerrank                 [%]     :youtube:competitive_programming:
*** TODO codejam                    [%]     :youtube:competitive_programming:
*** TODO codemasrytube                [%]   :youtube:competitive_programming:
*** TODO mycodeschool                  [%]  :youtube:competitive_programming:
*** TODO saurabhschool              [%]     :youtube:competitive_programming:
*** TODO codinginterviewhub      [%]        :youtube:competitive_programming:
*** TODO conor                [%]           :youtube:competitive_programming:
*** TODO geeksforgeeks [%]                  :youtube:competitive_programming:
*** TODO Elementry Number Theory - 6th Edition - Kenneth H. Rosen [%] 
    [[file:3.Sources/NumberTheory/Books/Elementary%20Number%20Theory%20-%206th%20Edition%20-%20Kenneth%20H.%20Rosen.pdf][file:3.Sources/NumberTheory/Books/Elementary Number Theory - 6th Edition - Kenneth H. Rosen.pdf]]  



    -----

*** TODO Machine Learning - Stanford [%]
**** 01.2-V2-Introduction-WhatIsMachineLearning.mp4
**** 01.3-V2-Introduction-SupervisedLearning.mp4
**** 01.4-V2-Introduction-UnsupervisedLearning.mp4
**** 02.1-V2-LinearRegressionWithOneVariable-ModelRepresentation.mp4
**** 02.2-V2-LinearRegressionWithOneVariable-CostFunction.mp4
**** 02.3-V2-LinearRegressionWithOneVariable-CostFunctionIntuitionI.mp4
**** 02.4-V2-LinearRegressionWithOneVariable-CostFunctionIntuitionII.mp4
**** 02.5-V2-LinearRegressionWithOneVariable-GradientDescent.mp4
**** 02.6-V2-LinearRegressionWithOneVariable-GradientDescentIntuition.mp4
**** 02.7-V2-LinearRegressionWithOneVariable-GradientDescentForLinearRegression.mp4
**** 02.8-V2-What'sNext.mp4
**** 03.1-V2-LinearAlgebraReview(Optional)-MatricesAndVectors.mp4
**** 03.2-V2-LinearAlgebraReview(Optional)-AdditionAndScalarMultiplication.mp4
**** 03.3-V2-LinearAlgebraReview(Optional)-MatrixVectorMultiplication.mp4
**** 03.4-V2-LinearAlgebraReview(Optional)-MatrixMatrixMultiplication.mp4
**** 03.5-V2-LinearAlgebraReview(Optional)-MatrixMultiplicationProperties.mp4
**** 03.6-V2-LinearAlgebraReview(Optional)-InverseAndTranspose.mp4
**** 04.1-LinearRegressionWithMultipleVariables-MultipleFeatures.mp4
**** 04.2-LinearRegressionWithMultipleVariables-GradientDescentForMultipleVariables.mp4
**** 04.3-LinearRegressionWithMultipleVariables-GradientDescentInPracticeIFeatureScaling.mp4
**** 04.4-LinearRegressionWithMultipleVariables-GradientDescentInPracticeIILearningRate.mp4
**** 04.5-LinearRegressionWithMultipleVariables-FeaturesAndPolynomialRegression.mp4
**** 04.6-V2-LinearRegressionWithMultipleVariables-NormalEquation.mp4
**** 04.7-LinearRegressionWithMultipleVariables-NormalEquationNonInvertibility(Optional).mp4
**** 05.1-OctaveTutorial-BasicOperations.mp4
**** 05.2-OctaveTutorial-MovingDataAround.mp4
**** 05.3-OctaveTutorial-ComputingOnData.mp4
**** 05.4-OctaveTutorial-PlottingData.mp4
**** 05.5-OctaveTutorial-ForWhileIfStatementsAndFunctions.mp4
**** 05.6-OctaveTutorial-Vectorization.mp4
**** 05.7-OctaveTutorial-WorkingOnAndSubmittingProgrammingExercises.mp4
**** 06.1-LogisticRegression-Classification.mp4
**** 06.2-LogisticRegression-HypothesisRepresentation.mp4
**** 06.3-LogisticRegression-DecisionBoundary.mp4
**** 06.4-LogisticRegression-CostFunction.mp4
**** 06.5-LogisticRegression-SimplifiedCostFunctionAndGradientDescent.mp4
**** 06.6-LogisticRegression-AdvancedOptimization.mp4
**** 06.7-LogisticRegression-MultiClassClassificationOneVsAll.mp4
**** 07.1-Regularization-TheProblemOfOverfitting.mp4
**** 07.2-Regularization-CostFunction.mp4
**** 07.3-Regularization-RegularizedLinearRegression.mp4
**** 07.4-Regularization-RegularizedLogisticRegression.mp4
**** 08.1-NeuralNetworksRepresentation-NonLinearHypotheses.mp4
**** 08.2-NeuralNetworksRepresentation-NeuronsAndTheBrain.mp4
**** 08.3-NeuralNetworksRepresentation-ModelRepresentationI.mp4
**** 08.4-NeuralNetworksRepresentation-ModelRepresentationII.mp4
**** 08.5-NeuralNetworksRepresentation-ExamplesAndIntuitionsI.mp4
**** 08.6-NeuralNetworksRepresentation-ExamplesAndIntuitionsII.mp4
**** 08.7-NeuralNetworksRepresentation-MultiClassClassification.mp4
**** 09.1-NeuralNetworksLearning-CostFunction.mp4
**** 09.2-NeuralNetworksLearning-BackpropagationAlgorithm.mp4
**** 09.3-NeuralNetworksLearning-BackpropagationIntuition.mp4
**** 09.3-NeuralNetworksLearning-ImplementationNoteUnrollingParameters.mp4
**** 09.4-NeuralNetworksLearning-GradientChecking.mp4
**** 09.5-NeuralNetworksLearning-RandomInitialization.mp4
**** 09.7-NeuralNetworksLearning-PuttingItTogether.mp4
**** 09.8-NeuralNetworksLearning-AutonomousDrivingExample.mp4
**** 10.1-AdviceForApplyingMachineLearning-DecidingWhatToTryNext.mp4
**** 10.2-AdviceForApplyingMachineLearning-EvaluatingAHypothesis.mp4
**** 10.3-AdviceForApplyingMachineLearning-ModelSelectionAndTrainValidationTestSets.mp4
**** 10.4-AdviceForApplyingMachineLearning-DiagnosingBiasVsVariance.mp4
**** 10.5-AdviceForApplyingMachineLearning-RegularizationAndBiasVariance.mp4
**** 10.6-AdviceForApplyingMachineLearning-LearningCurves.mp4
**** 10.7-AdviceForApplyingMachineLearning-DecidingWhatToDoNextRevisited.mp4
**** 11.1-MachineLearningSystemDesign-PrioritizingWhatToWorkOn.mp4
**** 11.2-MachineLearningSystemDesign-ErrorAnalysis.mp4
**** 11.3-MachineLearningSystemDesign-ErrorMetricsForSkewedClasses.mp4
**** 11.4-MachineLearningSystemDesign-TradingOffPrecisionAndRecall.mp4
**** 11.5-MachineLearningSystemDesign-DataForMachineLearning.mp4
**** 12.1-SupportVectorMachines-OptimizationObjective.mp4
**** 12.2-SupportVectorMachines-LargeMarginIntuition.mp4
**** 12.3-SupportVectorMachines-MathematicsBehindLargeMarginClassificationOptional.mp4
**** 12.4-SupportVectorMachines-KernelsI.mp4
**** 12.5-SupportVectorMachines-KernelsII.mp4
**** 12.6-SupportVectorMachines-UsingAnSVM.mp4
**** 14.1-Clustering-UnsupervisedLearningIntroduction.mp4
**** 14.2-Clustering-KMeansAlgorithm.mp4
**** 14.3-Clustering-OptimizationObjective.mp4
**** 14.4-Clustering-RandomInitialization.mp4
**** 14.5-Clustering-ChoosingTheNumberOfClusters.mp4
**** 15.1-DimensionalityReduction-MotivationIDataCompression.mp4
**** 15.2-DimensionalityReduction-MotivationIIVisualization.mp4
**** 15.3-DimensionalityReduction-PrincipalComponentAnalysisProblemFormulation.mp4
**** 15.4-DimensionalityReduction-PrincipalComponentAnalysisAlgorithm.mp4
**** 15.5-DimensionalityReduction-ChoosingTheNumberOfPrincipalComponents.mp4
**** 15.6-DimensionalityReduction-ReconstructionFromCompressedRepresentation.mp4
**** 15.7-DimensionalityReduction-AdviceForApplyingPCA.mp4
**** 16.1-AnomalyDetection-ProblemMotivation-V1.mp4
**** 16.2-AnomalyDetection-GaussianDistribution.mp4
**** 16.3-AnomalyDetection-Algorithm.mp4
**** 16.4-AnomalyDetection-DevelopingAndEvaluatingAnAnomalyDetectionSystem.mp4
**** 16.5-AnomalyDetection-AnomalyDetectionVsSupervisedLearning-V1.mp4
**** 16.6-AnomalyDetection-ChoosingWhatFeaturesToUse.mp4
**** 16.7-AnomalyDetection-MultivariateGaussianDistribution-OPTIONAL.mp4
**** 16.8-AnomalyDetection-AnomalyDetectionUsingTheMultivariateGaussianDistribution-OPTIONAL.mp4
**** 17.1-RecommenderSystems-ProblemFormulation.mp4
**** 17.2-RecommenderSystems-ContentBasedRecommendations.mp4
**** 17.3-RecommenderSystems-CollaborativeFiltering-V1.mp4
**** 17.4-RecommenderSystems-CollaborativeFilteringAlgorithm.mp4
**** 17.5-RecommenderSystems-VectorizationLowRankMatrixFactorization.mp4
**** 17.6-RecommenderSystems-ImplementationalDetailMeanNormalization.mp4
**** 18.1-LargeScaleMachineLearning-LearningWithLargeDatasets.mp4
**** 18.2-LargeScaleMachineLearning-StochasticGradientDescent.mp4
**** 18.3-LargeScaleMachineLearning-MiniBatchGradientDescent.mp4
**** 18.4-LargeScaleMachineLearning-StochasticGradientDescentConvergence.mp4
**** 18.5-LargeScaleMachineLearning-OnlineLearning.mp4
**** 18.6-LargeScaleMachineLearning-MapReduceAndDataParallelism.mp4
**** 19.1-ApplicationExamplePhotoOCR-ProblemDescriptionAndPipeline.mp4
**** 19.2-ApplicationExamplePhotoOCR-SlidingWindows.mp4
**** 19.3-ApplicationExamplePhotoOCR-GettingLotsOfDataArtificialDataSynthesis.mp4
**** 19.4-ApplicationExamplePhotoOCR-CeilingAnalysisWhatPartOfThePipelineToWorkOnNext.mp4
**** 20.1-Conclusion-SummaryAndThankYou.mp4

*** TODO MIT 6.042J Mathematics for Computer Science, Spring 2015 [4%]
    source: https://www.youtube.com/playlist?list=PLUl4u3cNGP60UlabZBeeqOuoLuj_KNphQ
**** DONE 1.1.1 Welcome to 6.042-wIq4CssPoO0.mp4
     CLOSED: [2017-03-01 Wed 18:41]
**** DONE 1.1.2 Intro to Proofs - Part 1-GyFVgJZ0hIs.mp4
     CLOSED: [2017-03-01 Wed 18:38]
**** DONE 1.1.3 Intro to Proofs - Part 2-wfr4XbR5VP8.mp4
     CLOSED: [2017-03-01 Wed 18:39]
**** DONE 1.2.1 Proof by Contradiction-CpW0ZJ7i0oc.mp4
     CLOSED: [2017-03-01 Wed 19:32]
**** DONE 1.2.3 Proof by Cases-vzpFQ3uNyPo.mp4
     CLOSED: [2017-03-01 Wed 19:32]
**** TODO 1.3.1 Well Ordering Principle 1 - Video-fV3v6qQ3w4A.mp4
**** TODO 1.3.3 Well Ordering Principle 2 - Video-I1HpgnWQI7I.mp4
**** TODO 1.3.5 Well Ordering Principle 3 - Video-hNrtGiCFPGs.mp4
**** TODO 1.4.1 Propositional Operators - Video-0exBzsexUoI.mp4
**** TODO 1.4.3 Digital Logic - Video-eMWG-jTh-GE.mp4
**** TODO 1.4.4 Truth Tables - Video-_3WDzxt5p8c.mp4
**** TODO 1.5.1 Predicate Logic 1 - Video-UroprmQHTLc.mp4
**** TODO 1.5.2 Predicate Logic 2 - Video-T1AtlGrCoU8.mp4
**** TODO 1.5.4 Predicate Logic 3 - Video-L5uBeAGJV1k.mp4
**** TODO 1.6.1 Sets Definitions - Video-KZ7jjLTQ9r4.mp4
**** TODO 1.6.2 Sets Operations - Video-Mhip1rljvRo.mp4
**** TODO 1.7.1 Relations - Video-FkfsmwAtDdY.mp4
**** TODO 1.7.3 Relational Mappings - Video-gFD1Lp6zK3w.mp4
**** TODO 1.7.5 Finite Cardinality - Video-fpy5Hsz5t6E.mp4
**** TODO 1.8.1 Induction - Video-XnV8GAuAqJM.mp4
**** TODO 1.8.2 Bogus Induction - Video-D3E5CKebKuQ.mp4
**** TODO 1.8.4 Strong Induction - Video-TUueMeRooBk.mp4
**** TODO 1.8.6 WOP vs Induction - Video [optional]-K8ZfzNN1miQ.mp4
**** TODO 1.9.3 Derived Variables - Video-a7JUH-EtHtI.mp4
**** TODO 1.10.1 Recursive Data - Video-TXNXT3oBROw.mp4
**** TODO 1.10.4 Structural Induction - Video-VWIDwHCGJDQ.mp4
**** TODO 1.10.7 Recursive Functions - Video-tOsdeaYDCMk.mp4
**** TODO 1.11.11 Set Theory Axioms - Video [Optional]-zcvsyL7GtH4.mp4
**** TODO 1.11.1 Cardinality - Video-QzSCf62kzjE.mp4
**** TODO 1.11.3 Countable Sets - Video-AipSRi3CyLg.mp4
**** TODO 1.11.4 Cantor's Theorem - Video-4dj1ogUwTEM.mp4
**** TODO 1.11.7 The Halting Problem - Video [Optional]-WQHOImO0pX0.mp4
**** TODO 1.11.9 Russell's Paradox - Video-5hETv64GIuE.mp4

**** TODO 2.1.1 GCDs & Linear Combinations - Video-et3FOZdI6pk.mp4
**** TODO 2.1.2 Euclidean Algorithm - Video-dW0f62lcCLE.mp4
**** TODO 2.1.4 Pulverizer - Video-yzKPotFLfsc.mp4
**** TODO 2.1.6 Revisiting Die Hard - Video-c3qNBNl1h8g.mp4
**** TODO 2.1.7 Prime Factorization - Video-QsKtEuUyIdw.mp4
**** TODO 2.2.1 Congruence mod n - Video-KvtLWgCTwn4.mp4
**** TODO 2.2.3 Inverses mod n - Video-CAKSh3M0y8k.mp4
**** TODO 2.3.1 Modular Exponentiation Euler's Function - Video-TeRYL7kkhqs.mp4
**** TODO 2.3.3 The Ring Z - Video-dZgI16nMuqE.mp4
**** TODO 2.4.1 RSA Public Key Encryption - Video-ZUZ8VbX1YNQ.mp4
**** TODO 2.4.3 Reducing Factoring To SAT - Video-yWIQCewgfwY.mp4
**** TODO 2.5.1 Digraphs - Walks & Paths - Video-MX-mBxt6huU.mp4
**** TODO 2.5.3 Digraphs - Connected Vertices - Video-QORX1OUabio.mp4
**** TODO 2.6.1 DAGs - Video-Sdw8_0RDZuw.mp4
**** TODO 2.6.3 Scheduling - Video-1TpzSCMLg08.mp4
**** TODO 2.6.5 Time versus Processors - Video-cUYTlKA8jaw.mp4
**** TODO 2.7.1 Partial Orders - Video-0w9luYcxHrw.mp4
**** TODO 2.7.3 Representing Partial Orders As Subset Relations - Video-bHvMYZvZp7Y.mp4
**** TODO 2.7.4 Equivalence Relations - Video-s-E5T3igntw.mp4
**** TODO 2.8.1 Degree - Video-TIpnudrzvgg.mp4
**** TODO 2.8.3 Isomorphism - Video-hVerxuP4cFg.mp4
**** TODO 2.9.1 Coloring - Video-Penh4mv5gAg.mp4
**** TODO 2.9.3 Connectivity - Video-TIQ3xN38jgM.mp4
**** TODO 2.9.4 k-Connectivity - Video-5wCZqdCDafc.mp4
**** TODO 2.10.1 Trees - Video-ZEsk64C0fJg.mp4
**** TODO 2.10.3 Tree Coloring - Video-g2mOvmC1TKc.mp4
**** TODO 2.10.5 Spanning Trees - Video-_RqqzyWDVMA.mp4
**** TODO 2.11.1 Stable Matching - Video-RE5PmdGNgj0.mp4
**** TODO 2.11.2 Matching Ritual - Video-6vgHIImFwHo.mp4
**** TODO 2.11.5 Optimal Stable Matching - Video-n4KKgKpp--0.mp4
**** TODO 2.11.7 Bipartite Matching-HZLKDC9OSaQ.mp4
**** TODO 2.11.9 Hall's Theorem-i5AWE-OoOsY.mp4

**** TODO 3.1.1 Arithmetic Sums - Video-v6axtBS6IF8.mp4
**** TODO 3.1.3 Geometric Sums - Video-ZDQk45NQbEo.mp4
**** TODO 3.1.5 Book Stacking - Video-CdhuVhWTSMI.mp4
**** TODO 3.1.7 Integral Method - Video-EegG5TPL29c.mp4
**** TODO 3.1.9 Stirling's Formula - Video-lU_QT5GSuxI.mp4
**** TODO 3.2.1 Asymptotic Notation - Video-CWkh5kb4TGc.mp4
**** TODO 3.2.3 Asymptotic Properties - Video-HeyEK0TWiBw.mp4
**** TODO 3.2.6 Asymptotic Blunders-Y9Blo_G-Mvg.mp4
**** TODO 3.3.1 Sum And Product Rules - Video-yTrtVwKZkwU.mp4
**** TODO 3.3.3 Counting with Bijections - Video-n0lce1dMAh8.mp4
**** TODO 3.4.1 Generalized Counting Rules - Video-iDfyX8WRIyM.mp4
**** TODO 3.4.3 Two Pair Poker Hands - Video-HswnmlLPGZ4.mp4
**** TODO 3.4.4 Binomial Theorem - Video-jwjDj4GoSV0.mp4
**** TODO 3.4.5 Multinomial Theorem - Video-juGgfHsO-xM.mp4
**** TODO 3.5.1 The Pigeonhole Principle - Video-4Dz4vNUxnZM.mp4
**** TODO 3.5.3 Inclusion-Exclusion Example - Video-51-b2mgZVNY.mp4
**** TODO 3.5.4 Inclusion-Exclusion 2 Sets - Video-nwpzBE9IwJQ.mp4

**** TODO 4.1.1 Tree Model - Video-dEsFEK4vnV4.mp4
**** TODO 4.1.3 Simplified Monty Hall Tree - Video-L30HPgryd6I.mp4
**** TODO 4.1.5 Sample Spaces - Video-Amd_bNYzgUw.mp4
**** TODO 4.2.1 Conditional Probability Definitions - Video-Cu9_LaaWgHo.mp4
**** TODO 4.2.3 Law of Total Probability - Video-F3y8qupFfUs.mp4
**** TODO 4.2.5 Bayes' Theorem - Video-e-yQFC6dACA.mp4
**** TODO 4.2.7 Monty Hall Problem - Video-BEAv82FinM0.mp4
**** TODO 4.3.1 Independence - Video-1vQ2x5O_xqk.mp4
**** TODO 4.3.3 Mutual Independence - Video-wJzBU7Do1ls.mp4
**** TODO 4.4.1 Bigger Number Game - Video-BH4qlkYCLW0.mp4
**** TODO 4.4.2 Random Variables - Independence - Video-VJzv6WJTtNc.mp4
**** TODO 4.4.4 Random Variables - Uniform & Binomial - Video-L2yOSFsMvnc.mp4
**** TODO 4.5.1 Expectation - Video-YVQdVzSkcmQ.mp4
**** TODO 4.5.3 Expected Number Of Heads - Video-D9l-pIg1Ayo.mp4
**** TODO 4.5.5 Total Expectation - Video-mqoDXWrSais.mp4
**** TODO 4.5.7 Mean Time to Failure - Video-Dqx56lZ_icg.mp4
**** TODO 4.5.9 Linearity of Expectation - Video-KFcodn4qfrQ.mp4
**** TODO 4.6.1 Deviation From The Mean - Video-ALn1McUXg-c.mp4
**** TODO 4.6.3 Markov Bounds - Video-m07lrb7m0D0.mp4
**** TODO 4.6.5 Chebyshev Bounds - Video-uaa4P-kkLrA.mp4
**** TODO 4.6.7 Variance - Video-o57CTwt1-ck.mp4
**** TODO 4.7.1 Law Of Large Numbers - Video--yo3YxfY47g.mp4
**** TODO 4.7.3 Independent Sampling Theorem - Video-MMn7q1M7pGI.mp4
**** TODO 4.7.5 Birthday Matching - Video-TWVntUfXsKs.mp4
**** TODO 4.7.7 Sampling & Confidence - Video-Q-6Cw8tYVeY.mp4
**** TODO 4.8.1 Random Walks - Video--j7MoM3P_J8.mp4
**** TODO 4.8.2 Stationary Distributions - Video-iZX8WEGZTVw.mp4
**** TODO 4.8.3 Page Rank - Video-QKO_2WQkZ0k.mp4

*** TODO Machine Learning, 1997 by Tom M. Mitchell [0%]
**** TODO Introduction
**** TODO Concept Learning and the General-to-Specific Ordering 
**** TODO Decision Tree Learning
**** TODO Artificial Neural Networks 
**** TODO Evaluating Hypotheses 
**** TODO Bayesian Learning  
**** TODO Computational Learning Theory 
**** TODO Instance-Based Learning 
**** TODO Genetic Algorithms 
**** TODO Learning Sets of Rules 
**** TODO Analytical Learning 
**** TODO Combining Inductive And Analytical Learning 
**** TODO Reinforcement Learning

*** TODO MIT6.034ArtificialIntelligenceFall2010 [0%]
    done 1,2,3,4, still downloading the rest...

    
* Problems
** TODO Spaceship Defence
   https://code.google.com/codejam/contest/2924486/dashboard#s=p4
   
   - *Teleporters*: 
     - (P) Teleporters allow your soldiers to move instantly between rooms.
     - (P) Every room contains a teleporter, and rooms are color-coded.
     - (I) *if* a soldier is in a room with some color, 
       *then* the solider can use the teleporter in that room to immediately move to any other room with the same color. 

   - *Turbolifts*:
     - (P) Turbolifts allow your soldiers to move between rooms more slowly.
     - (P) A turbolift is like an elevator that moves in many directions.
     - (P) Each turbolift moves from one room to one other room.
     - (P) it takes a certain amount of time *t* to travel. 
     - (I) Turbolifts are not two-way: 
       *if* a turbolift moves soldiers from room a to room b, 
       *then* the same turbolift cannot move soldiers from room b
       to room a, 
       *although* there might be another turbolift that does that.
     - (P) More than one soldier can use the same turbolift, and they do not interfere with each other in any way.

   - *Given*
     - *locations* and *destinations* of several soliders 
   - *Required*
     - For each soldier, *output the minimum amount of time* it could take that soldier to travel from his location to his destination.
*** Input
    The first line of the input gives the number of test cases, T; T
    test cases follow. For every test case:
    - *rooms* 
      - The first line of every test case contains an integer N, which
        is the number of rooms in your spaceship. 
      - The rooms are numbered from 1 to N. 
      - The following N lines each contain a string telling the color of the rooms, from room 1 to room N. 
      - The strings only contain characters a-z (the lower-case
        English letters) and 0-9 (the number 0 to 9), and the length of each string will be less than or equal to 2.

    - *turbolifts* 
      - The next line in the test case is an integer M, 
        which indicates the number of turbolifts in your spaceship. 
      - The following M lines each contain 3 space-separated integers ai,
        bi, ti, telling us that there is a turbolift that can transport 
        soldiers from room ai to room bi in ti seconds.

    - *Soliders* 
      - The next line in the test case contains an integer S, which is the number of soldiers at your command. 
      - The following S lines each contain two integers: the location and destination of one soldier, pj and qj.


** TODO Journey to the moon                              :graphtheory:medium: 
   :PROPERTIES:   
   :SCHEDULED: <2017-03-13 Mon +2d/4d>
   :DESCRIPTION: hackerrank problem, found in rookierank2 contest, its about dupilcates in an array
   :Difficulty: medium
   :CATEGORY: graphtheory
   :Source:   https://www.hackerrank.com/challenges/journey-to-the-moon
   :LAST_REPEAT: [2017-02-24 Fri 12:37]
   :END:
   
   The member states of the UN are planning to send  people to the Moon. 
   But there is a problem. 
   In line with their principles of global unity, 
   they want to pair astronauts of 2 different countries.

   There are N trained astronauts numbered from 0 to N - 1. 
   But those in charge of the mission did not receive information about the 
   citizenship of each astronaut. 

   The only information they have is that some particular pairs of 
   astronauts belong to the same country.

   Your task is to compute in how many ways they can pick a pair of 
   astronauts belonging to different countries. 
   Assume that you are provided enough pairs to let you identify the 
   groups of astronauts even though you might not know their country directly. 

   For instance, if  are astronauts from the same country; 
   it is sufficient to mention that  and  are pairs of astronauts from 
   the same country without providing information about a third pair . 

** Birthday Cake Candles  
   :PROPERTIES:   
   :SCHEDULED: <2017-02-19 Sun +2d/4d>
   The repeat specification, .+2d/4d means:
   Repeat as frequently as every two days, but
   Never less frequently than every four days, and
   When completed, start counting again from today. 
   :DESCRIPTION: hackerrank problem, found in rookierank2 contest, its about dupilcates in an array
   :Difficulty: easy  
   :CATEGORY: search algorithms 
   :Source:      https://www.hackerrank.com/contests/rookierank/challenges/birthday-cake-candles
   :ZPT:      1
   :END:
** :problem:
   -  Colleen is turning  \(n\)  years old!                        
   - She has  \(n\)  candles of various heights on her cake, 
   - Candle \(i\) has height \(heighti\) . Because the taller candles tower over the shorter ones, Colleen can only blow out the tallest candles.
   -  Given the  for each individual candle, find and print the number of candles she can successfully blow out.
*** :input: 
    - The first line contains a single integer, , denoting the number of candles on the cake. 
    - The second line contains  space-separated integers, where each integer  describes the height of candle .
*** :constraints:
    none
*** :output: 
    - Print the number of candles Colleen blows out on a new line.
*** :explanation:
    - 1..
    - 2.. 
** :solution:
*** :questions:
    none
*** :predicates:   
    - the brute force solution gives O(N^2) via comparing each of two strings. 
    - A common technique is the trade-off between time and space. 
    - We want to make the algorithm faster, we can think of how to use more memory to solve the problem. .
    - The keyphrase “find duplicate”, is translated to "use a hash set" immediately,  as hash is the most common technique to detect duplicates. 
*** :implications:
    - If we store every element into a hash set, we can make it O(N) for both time and space complexity.
    #+BEGIN_SRC ruby
      def input
        p "love emacs, because emacs is a philosphy of how yo all dealing with computer..."
      end
      def output
      end       
      input
    #+END_SRC

    #+RESULTS: 
    : love emacs, because emacs is a philosphy of how yo all dealing with computer

** References       
   - source: https://www.hackerrank.com/contests/rookierank/challenges/birthday-cake-candles
   - ref: http://blog.gainlo.co/index.php/2016/05/10/duplicate-elements-of-an-array/

   ----- 

** TODO Somthing 
   :PROPERTIES:   
   :SCHEDULED: <2017-02-19 Sun +2d/4d>
   :DESCRIPTON: hackerrank problem, found in....
   :Difficulty: easy
   :CATEGORY: none
   :Source:   none
   :ZPT:      1
   :END:
*** :problem:
    -  something
**** :input: 
     - none 
**** :constraints:
     - none
**** :output: 
     - none
**** :explanation:
     - none
*** :solution:
**** :questions:
     - none
**** :predicates:   
     - none
**** :implications:
     - none
       #+BEGIN_SRC ruby
       #+END_SRC
       #+BEGIN_SRC C 
       #+END_SRC
*** References       
    -  none

      -----

** Battlecode
   MIT AI game #battlecode@freenode.net

** ProblemName KnightL on a Chessboard
** ProblemStatment 
   is a chess piece that moves in an L shape. We define the possible moves of  as any movement from some position  to some  satisfying either of the following:
** Input Format 
** Constraints
** Out Format
** Solution 
** Theatre Square                                :website:codeforces:contest:

   source: http://codeforces.com/contest/1/problem/A
   ----- 


  
   keep log of all the interviews I made and schedules for upcoming interviews, as well as info for mastering the
   art of interviews. 
  
   Some people make multiple interviews with fake names, imporsnating someone who doens't
   have a public profile photo on twitter and github, they require a fake skypename for that! You are too lazy for this :))

** References       
   - not related to the problem but good to notice https://en.wikipedia.org/wiki/Knight's_tour
     

   ----- 

 **** TODO add vjudge owner on whatsapp and wechat and talkk
**** TODO use a tiled window manager instead of openbox to watch videos and emacs at teh same time

     
* Distractions 
  write down distractions here to focus on task at hand, good for the focus muscle, 
  watch https://www.youtube.com/watch?v=H0k0TQfZGSc
** TODO Index CodeJam website and collection all their problem sets and Answers!.
** TODO Org-mode shortcuts for SQ3R
   - If I press space-q then I get (Q) with color red
   - If I press space-p then I get (P) with color blue
   - If I press space-p then I get (I) with color green
   - If I press space-p then I get (I) with color yellow
** TODO how to get all the file names from a folder and write them in a ** Reference TODO
** TODO how to do references between the * Knoweldge and ** References  
** DONE ban facebook
   CLOSED: [2017-03-01 Wed 01:11]
   /etc/hosts
   0.0.0.1         facebook.com    
   0.0.0.1         www.facebook.com

** Hackertyper for reviewing practiced algorithms
  I should use hackertyper to review practiced algorithms,
  ref: http://www.hackertyper.com/
  
** How to use emacs in my life?
   So the idea is that I while I want to code, I code in C or ruby file using its respective emacs-mode and its capabilities, but when i want to take notes and log it into my blog, 
   I use org-capture. as I am very neat and I know what kind of stuff I add into my single-page blog, I have created many templates to my various data contents, 
   example: if i am solving a hackerrank problem and i got it to pass, and now I want to add it to my blog, I just press C-cc followed by h or similar to start editing the hackerrank template, C-c C-c to finish 
   and have it saved to the end of my blog with all the correct tags that gets viewed via emacs agenda later on. 

   This is so powerful that I can create many powerful org-capture templates and save it in my .emacs and keep enhancing them to reflect my level of performance in study, practice and work. 

   *use C-c \* to search for zpd0, zpd1, zpd2 tags and find what you are trying to do that day, and C-c C-c to choose the tags
   *use space-p* to add new empty line in org-mode
** PracticeTips:
   - Whenever you solve some questions, try to ask yourself what if we *expand the question to a larger scale!*
   - *Revisit old problems* and think about new techqinues, better ways, different contexts, different constrains, etc.  
   - every solution is a finite state automata
**  use inf-ruby more often please
   ;; inf-ruby
   ;;Use C-c C-s to launch the inf-ruby process.
   ;;Use C-x o to switch to the inf-ruby pane and try running some random ruby snippets as you normally would from IRB or pry.
   ;;Go back to your Ruby buffer, select (by highlighting) a chunk of code, and use C-c C-r to push that Ruby code into the IRB session.
   ;;For example, try defining a class in your Ruby buffer, select the whole buffer, run C-c C-r, then swap over to the inf-ruby buffer and instantiate an instance of your class. Pretty cool!
   ;;Alternatively, use C-c M-r to run a selected chunk of code and automatically go to the ruby buffer
   ;;Finally, use helm-M-x (which we bound earlier to the default M-x keybinding) to search for âruby sendâ and see what other default bindings inf-ruby gives us.
   ;;If you do a lot of work in Rails or Sinatra, check out the commands inf-ruby-console-rails and inf-ruby-console-racksh. Using these commands inf-ruby can start a console session in the environment of your web project.
   (autoload 'inf-ruby-minor-mode "inf-

** TODO
   - create templates for hackerrank problems, store in zotherstupidguy.github.io/org/templates/hackerrank.text
   - codeforces problems, store in zotherstupidguy.github.io/org/templates/codeforces.text
   - experiment with org-mode agenda to view my headings based on their tags? or a smiliar functionality from somthing else maybe! 
   - use org-capture for saving common algorithms in C. eg. sorting.c shortestpath.c, etc.
   - find the ability to query my huge org file.  
   - on emacs open, make sure it opens scratch and also opens index.org and make index.org the active buffer to easily edit.
   - org-capture template for Questions, Predicates, and Implications

** Emacs Agenda :agenda:
   The agenda allows you to create filtered views of the items in your 
   *agenda files*("day-planner" views of your schedule, lists of your todos, and the results of queries (for tags, words, regular expressions, etc.)).

   One use of the agenda is as a day planner system. If you prefer to schedule your tasks and to see a daily agenda of TODOs, you'll probably be pressing C-c a a a lot.
   The agenda can also be used for a powerful GTD system. If you like to filter your "next actions" by context, 
   then you'll probably make frequent use of C-c a t to see a list of all your active TODOs and to filter them by tag/context.
   While the agenda is a powerful task management tool, it is also a fantastic research tool. If you keep a file full of reading notes, 
   for instance, you can use the agenda to locate entries containing a particular word or labeled by a particular tag.

   *Do you want quickly to filter for the item in the agenda view? If so, a tag is probably your best choice.*
   Note, you can add a setting to your .emacs that automatically adds a tag whenever you assign a particular TODO keyword. Type "C-c v org-todo-state-tags-triggers" for more information.
   An excellent way to implement labels and contexts for cross-correlating information is to assign tags to headlines. Org mode has extensive support for tags.

   Every headline can contain a list of tags; they occur at the end of the headline. Tags are normal words containing letters, numbers, ‘_’, and ‘@’. Tags must be preceded and followed by a single colon, e.g., ‘:work:’. Several tags can be specified, as in ‘:work:urgent:’. Tags will by default be in bold face with the same color as the headline.

   Tag inheritance: Tags use the tree structure of the outline
   Setting tags: How to assign tags to a headline
   Tag groups: Use one tag to search for several tags
   Tag searches: Searching for combinations of tags
   ref: http://orgmode.org/guide/Tags.html#Tags
  
** C programs debugging via GDB in Emacs   
   https://kb.iu.edu/d/aqsy
  


** TODO Viewing images inside emacs (org-mode)
** TODO add vjudge owner on whatsapp and wechat and talkk
** TODO use a tiled window manager instead of openbox to watch videos and emacs at teh same time

